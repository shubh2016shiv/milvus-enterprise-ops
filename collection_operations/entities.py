"""
Entity models for Milvus collections.

This module defines Pydantic models for representing Milvus collection
states, statistics, and other metadata in a strongly-typed manner.

Note: This module uses Pydantic v1 style model definitions.
If upgrading to Pydantic v2, Config classes would need to be replaced with
model_config dictionaries and other v2 compatible patterns.
The current implementation is compatible with Pydantic v1.x.
"""

from enum import Enum
from typing import Dict, List, Optional, Any, Union
from datetime import datetime
from pydantic import BaseModel, Field

def try_parse_timestamp(timestamp_value: Union[float, int, str]) -> datetime:
    """
    Safely parse a timestamp value to a datetime object.
    
    This helper ensures type stability when working with timestamps from
    external sources that might be inconsistently typed.
    
    Args:
        timestamp_value: A timestamp value as float, int, or string
        
    Returns:
        A datetime object representing the timestamp, or current time if parsing fails
    """
    try:
        if isinstance(timestamp_value, (int, float)):
            return datetime.fromtimestamp(float(timestamp_value))
        elif isinstance(timestamp_value, str):
            return datetime.fromtimestamp(float(timestamp_value))
        else:
            return datetime.now()
    except (ValueError, TypeError):
        return datetime.now()

from .schema import CollectionSchema


class LoadState(str, Enum):
    """
    Enumeration of possible states for a collection's memory load status.
    
    This provides a clear, explicit representation of whether a collection is
    currently loaded into Milvus's memory for querying, unloaded, or in a
    transitional state.
    """
    UNLOADED = "Unloaded"
    LOADING = "Loading"
    LOADED = "Loaded"
    FAILED = "Failed"


class CollectionState(str, Enum):
    """
    Enumeration of possible lifecycle states for a collection.
    
    This is intended for future use in a more advanced, stateful management
    system. In the current implementation, collections are typically either
    `AVAILABLE` or in a transient state during operations.
    """
    CREATING = "Creating"
    AVAILABLE = "Available"
    DROPPING = "Dropping"
    DELETED = "Deleted"
    FAILED = "Failed"


class CollectionDescription(BaseModel):
    """
    A Pydantic model that provides a detailed description of a Milvus collection.
    
    This model encapsulates all the critical metadata about a collection, including
    its schema and current state. It is the primary object used to understand the
    structure and status of a collection.

    Attributes:
        name: The unique name of the collection.
        schema: The `CollectionSchema` object that defines the collection's structure.
        id: The unique identifier for the collection, assigned by Milvus.
        created_at: The timestamp when the collection was created.
        schema_hash: A deterministic hash of the functional parts of the schema, used
                     for verifying schema compatibility.
        state: The lifecycle state of the collection (e.g., `AVAILABLE`).
        load_state: The current memory load state of the collection (e.g., `LOADED`).
        created_at_is_synthetic: A boolean flag that is `True` if the `created_at`
                                 timestamp was generated by the client because it
                                 was not available from the server.
    """
    name: str = Field(..., description="The unique name of the collection.")
    schema: CollectionSchema = Field(..., description="The schema defining the collection's structure.")
    id: str = Field(..., description="The logical identifier of the collection. Note: This is a logical ID used for tracking, not necessarily a server-assigned GUID.")
    created_at: datetime = Field(..., description="The timestamp of when the collection was created.")
    schema_hash: str = Field(..., description="A hash of the functional schema for compatibility checks.")
    state: CollectionState = Field(CollectionState.AVAILABLE, description="The current lifecycle state of the collection.")
    load_state: LoadState = Field(LoadState.UNLOADED, description="The current memory load state of the collection.")
    created_at_is_synthetic: bool = Field(False, description="True if the creation timestamp was synthesized by the client.")
    
    class Config:
        """Pydantic configuration."""
        arbitrary_types_allowed = True


class SegmentInfo(BaseModel):
    """
    A Pydantic model representing information about a single segment within a collection.
    
    Segments are the fundamental data storage units in Milvus. This model provides
    detailed metadata about each segment, which is useful for monitoring and
    advanced performance analysis.

    Attributes:
        segment_id: The unique identifier for the segment.
        collection_id: The identifier of the collection this segment belongs to.
        partition_id: The identifier of the partition this segment belongs to.
        num_rows: The number of entities (vectors) stored in this segment.
        index_name: The name of the index applied to this segment, if any.
        state: The current state of the segment (e.g., `Sealed`, `Flushed`).
        created_at: The timestamp when the segment was created.
        memory_size: The size of the segment in memory, in bytes.
        disk_size: The size of the segment on disk, in bytes.
    """
    segment_id: str = Field(..., description="The unique identifier for the segment.")
    collection_id: str = Field(..., description="The ID of the collection this segment belongs to.")
    partition_id: str = Field(..., description="The ID of the partition this segment belongs to.")
    num_rows: int = Field(..., description="The number of entities stored in the segment.")
    index_name: Optional[str] = Field(None, description="The name of the index applied to the segment, if any.")
    state: str = Field(..., description="The current state of the segment (e.g., Sealed, Flushed).")
    created_at: datetime = Field(..., description="The timestamp of when the segment was created.")
    memory_size: Optional[int] = Field(None, description="The size of the segment in memory, in bytes.")
    disk_size: Optional[int] = Field(None, description="The size of the segment on disk, in bytes.")


class PartitionInfo(BaseModel):
    """
    A Pydantic model representing information about a single partition within a collection.
    
    Partitions are logical divisions of a collection that can help scope searches
    and improve query performance.

    Attributes:
        partition_id: The unique identifier for the partition.
        name: The name of the partition.
        collection_id: The identifier of the collection this partition belongs to.
        created_at: The timestamp when the partition was created.
        num_segments: The total number of segments within this partition.
        num_rows: The total number of entities (vectors) within this partition.
    """
    partition_id: str = Field(..., description="The unique identifier for the partition.")
    name: str = Field(..., description="The name of the partition.")
    collection_id: str = Field(..., description="The ID of the collection this partition belongs to.")
    created_at: datetime = Field(..., description="The timestamp of when the partition was created.")
    num_segments: int = Field(0, description="The total number of segments in the partition.")
    num_rows: int = Field(0, description="The total number of entities in the partition.")


class CollectionStats(BaseModel):
    """
    A Pydantic model that provides detailed statistics for a Milvus collection.
    
    This model aggregates various metrics about a collection, such as its size,
    number of entities, and details about its partitions and segments. It is
    essential for monitoring, capacity planning, and performance tuning.

    Attributes:
        name: The name of the collection.
        id: The unique identifier of the collection.
        created_at: The timestamp when the collection was created.
        row_count: The total number of entities (vectors) in the collection.
        memory_size: The total estimated memory size of the collection in bytes.
        disk_size: The total estimated disk size of the collection in bytes.
        index_size: The total estimated size of all indexes in the collection, in bytes.
        partitions: A list of `PartitionInfo` objects with details about each partition.
        segments: A list of `SegmentInfo` objects with details about each segment.
    """
    name: str = Field(..., description="The name of the collection.")
    id: str = Field(..., description="The logical identifier of the collection. Note: This is a logical ID used for tracking, not necessarily a server-assigned GUID.")
    created_at: datetime = Field(..., description="The timestamp of when the collection was created.")
    row_count: int = Field(0, description="The total number of entities in the collection.")
    memory_size: int = Field(0, description="The total memory size of the collection in bytes.")
    disk_size: int = Field(0, description="The total disk size of the collection in bytes.")
    index_size: int = Field(0, description="The total size of all indexes in the collection, in bytes.")
    partitions: List[PartitionInfo] = Field(
        default_factory=list, 
        description="A list of detailed information about each partition."
    )
    segments: List[SegmentInfo] = Field(
        default_factory=list, 
        description="A list of detailed information about each segment."
    )
    
    @property
    def num_partitions(self) -> int:
        """Get the number of partitions."""
        return len(self.partitions)
    
    @property
    def num_segments(self) -> int:
        """Get the number of segments."""
        return len(self.segments)
    
    @classmethod
    def from_milvus_response(cls, name: str, stats: Dict[str, Any]) -> "CollectionStats":
        """
        Create a CollectionStats object from a Milvus response.
        
        This class method serves as a factory to parse the raw dictionary returned
        by the Milvus SDK into a structured, validated `CollectionStats` object.

        Args:
            name: The name of the collection.
            stats: The raw statistics dictionary from the Milvus `get_collection_stats` call.
            
        Returns:
            A populated `CollectionStats` object.
        """
        # Extract basic stats
        row_count = stats.get("row_count", 0)
        
        # Extract collection ID and creation time
        collection_id = stats.get("collection_id", "")
        
        # Handle created_utc with type stability
        # Note: This is a client-synthesized timestamp if server omits it
        created_at = try_parse_timestamp(stats.get("created_utc", datetime.now().timestamp()))
        
        # Calculate sizes
        memory_size = 0
        disk_size = 0
        index_size = 0
        
        # Process segments
        segments = []
        for segment_data in stats.get("segments", []):
            segment = SegmentInfo(
                segment_id=segment_data.get("segment_id", ""),
                collection_id=collection_id,
                partition_id=segment_data.get("partition_id", ""),
                num_rows=segment_data.get("num_rows", 0),
                index_name=segment_data.get("index_name"),
                state=segment_data.get("state", "Unknown"),
                created_at=try_parse_timestamp(segment_data.get("created_utc", datetime.now().timestamp())),
                memory_size=segment_data.get("memory_size", 0),
                disk_size=segment_data.get("disk_size", 0)
            )
            segments.append(segment)
            
            # Update size totals - normalize by always using .get with default 0
            memory_size += segment.memory_size or 0
            disk_size += segment.disk_size or 0
            # Always account for index size regardless of index_name presence
            index_size += segment_data.get("index_size", 0)
        
        # Process partitions
        partitions = []
        partition_stats = {}
        
        # Group segments by partition
        for segment in segments:
            partition_id = segment.partition_id
            if partition_id not in partition_stats:
                partition_stats[partition_id] = {
                    "num_segments": 0,
                    "num_rows": 0
                }
            partition_stats[partition_id]["num_segments"] += 1
            partition_stats[partition_id]["num_rows"] += segment.num_rows
        
        # Create partition objects
        for partition_data in stats.get("partitions", []):
            partition_id = partition_data.get("partition_id", "")
            partition = PartitionInfo(
                partition_id=partition_id,
                name=partition_data.get("name", "_default"),
                collection_id=collection_id,
                created_at=try_parse_timestamp(partition_data.get("created_utc", datetime.now().timestamp())),
                num_segments=partition_stats.get(partition_id, {}).get("num_segments", 0),
                num_rows=partition_stats.get(partition_id, {}).get("num_rows", 0)
            )
            partitions.append(partition)
        
        return cls(
            name=name,
            id=collection_id,
            created_at=created_at,
            row_count=row_count,
            memory_size=memory_size,
            disk_size=disk_size,
            index_size=index_size,
            partitions=partitions,
            segments=segments
        )


class LoadProgress(BaseModel):
    """
    A Pydantic model representing the progress of a collection loading operation.
    
    This model provides real-time feedback on the status of loading a collection
    into memory, which can be a long-running operation for large collections.

    Attributes:
        collection_name: The name of the collection being loaded.
        state: The current `LoadState` of the operation (e.g., `LOADING`, `LOADED`).
        progress: The loading progress as a float between 0.0 and 1.0.
        loaded_segments: The number of segments that have been successfully loaded.
        total_segments: The total number of segments that need to be loaded.
        error_message: If the loading fails, this field contains the error message.
    """
    collection_name: str = Field(..., description="The name of the collection being loaded.")
    state: LoadState = Field(..., description="The current loading state of the collection.")
    progress: float = Field(..., description="The loading progress, from 0.0 to 1.0.")
    loaded_segments: int = Field(0, description="The number of segments successfully loaded.")
    total_segments: int = Field(0, description="The total number of segments to be loaded.")
    error_message: Optional[str] = Field(None, description="Contains an error message if the loading process failed.")
    
    @property
    def is_complete(self) -> bool:
        """Check if loading is complete (either successful or failed)."""
        return self.state == LoadState.LOADED or self.state == LoadState.FAILED
    
    @property
    def is_successful(self) -> bool:
        """Check if loading was successful."""
        return self.state == LoadState.LOADED
    
    @classmethod
    def from_milvus_response(cls, name: str, progress: Dict[str, Any]) -> "LoadProgress":
        """
        Create a LoadProgress object from a Milvus response.
        
        This class method serves as a factory to parse the raw dictionary returned
        by the Milvus SDK's progress API into a structured `LoadProgress` object.

        Args:
            name: The name of the collection.
            progress: The raw progress dictionary from the Milvus SDK.
            
        Returns:
            A populated `LoadProgress` object.
        """
        # Extract progress information
        loading_progress = progress.get("loading_progress", "0%")
        
        # Convert percentage string to float
        try:
            if isinstance(loading_progress, str) and loading_progress.endswith("%"):
                progress_value = float(loading_progress.rstrip("%")) / 100.0
            else:
                progress_value = float(loading_progress)
        except (ValueError, TypeError):
            progress_value = 0.0
        
        # Determine state based on progress
        if progress_value >= 1.0:
            state = LoadState.LOADED
        elif progress_value > 0.0:
            state = LoadState.LOADING
        else:
            state = LoadState.UNLOADED
        
        # Extract segment information if available
        loaded_segments = progress.get("loaded_segments", 0)
        total_segments = progress.get("total_segments", 0)
        
        return cls(
            collection_name=name,
            state=state,
            progress=progress_value,
            loaded_segments=loaded_segments,
            total_segments=total_segments,
            error_message=progress.get("error")
        )
